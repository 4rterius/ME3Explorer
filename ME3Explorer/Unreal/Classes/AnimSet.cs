//This class was generated by ME3Explorer
//Author: Warranty Voider
//URL: http://sourceforge.net/projects/me3explorer/
//URL: http://me3explorer.freeforums.org/
//URL: http://www.facebook.com/pages/Creating-new-end-for-Mass-Effect-3/145902408865659
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using ME3Explorer.Unreal;
using ME3Explorer.Packages;
using SharpDX;
using ME3Explorer.Debugging;

namespace ME3Explorer.Unreal.Classes
{
    public class AnimSet
    {
        #region Unreal Props

        //Name Properties

        public string PreviewSkelMeshName;
        //Object Properties

        public int m_pBioAnimSetData;
        //Array Properties

        public List<int> Sequences;

        #endregion

        public ExportEntry Export;
        public IMEPackage pcc;
        public byte[] data;
        public BioAnimSetData SetData;

        public AnimSet(ExportEntry export)
        {
            pcc = export.FileRef;
            Export = export;
            data = export.Data;

            PropertyCollection props = export.GetProperties();
            m_pBioAnimSetData = props.GetPropOrDefault<ObjectProperty>("m_pBioAnimSetData").Value;
            if (pcc.isExport(m_pBioAnimSetData))
            {
                SetData = new BioAnimSetData(pcc.getUExport(m_pBioAnimSetData));
            }
            PreviewSkelMeshName = props.GetPropOrDefault<NameProperty>("PreviewSkelMeshName").Value.InstancedString;
            Sequences = props.GetPropOrDefault<ArrayProperty<ObjectProperty>>("Sequences").Select(prop => prop.Value).ToList();
        }

        public TreeNode ToTree()
        {
            TreeNode res = new TreeNode($"AnimSet : {Export.ObjectName}(#{Export.UIndex})");
            res.Nodes.Add($"PreviewSkelMeshName : {PreviewSkelMeshName}");
            res.Nodes.Add($"m_pBioAnimSetData : {m_pBioAnimSetData}");
            if (SetData != null)
                res.Nodes.Add(SetData.ToTree());
            res.Nodes.Add(SequencesToTree());
            return res;
        }

        public TreeNode SequencesToTree()
        {
            TreeNode res = new TreeNode("Sequences");
            foreach (int idx in Sequences)
            {
                if (pcc.isUExport(idx) && pcc.getUExport(idx).ClassName == "AnimSequence")
                {
                    var ans = new AnimSequence(pcc.getUExport(idx));
                    res.Nodes.Add(ans.ToTree());
                }
                else                    
                    res.Nodes.Add(idx.ToString());
            }
            return res;
        }

        public void ExportToPSA(string path)
        {
            if (SetData == null)
                return;
            PSAFile psa = new PSAFile();
            PSAFile.PSAData d = psa.data;
            d.Bones = new List<PSAFile.PSABone>();                  //Export Bones
            int count = 0;
            foreach (string s in SetData.TrackBoneNames)
            {
                PSAFile.PSABone b = new PSAFile.PSABone();
                b.name = s;
                if (count == 0)
                    b.parent = -1;
                d.Bones.Add(b);
                count++;
            }
            d.Infos = new List<PSAFile.PSAAnimInfo>();              //Export Sequences
            d.Keys = new List<PSAFile.PSAAnimKeys>();
            int currframe = 0;
            for (int i = 0; i < Sequences.Count - 1; i++)
            {
                int idx = Sequences[i];
                int idxn = Sequences[i + 1];
                AnimSequence seq = new AnimSequence(pcc.getUExport(idx));
                AnimSequence seqn = new AnimSequence(pcc.getUExport(idxn));
                PSAFile.PSAAnimInfo inf = new PSAFile.PSAAnimInfo();
                inf.AnimRate = 30;
                inf.TotalBones = d.Bones.Count;
                inf.FirstRawFrame = currframe;
                inf.TrackTime = inf.NumRawFrames = seq.NumFrames;
                inf.KeyQuotum = inf.NumRawFrames * inf.TotalBones;
                inf.name = seq.SequenceName;
                inf.group = "None";
                d.Infos.Add(inf);
                for (int j = 0; j < inf.NumRawFrames; j++)
                    for (int k = 0; k < inf.TotalBones; k++)
                    {
                        Vector3 fromV = seq.CompressedTrackOffsets[k].Trans;
                        Vector3 toV = seqn.CompressedTrackOffsets[k].Trans;
                        Vector4 srotQ = seq.CompressedTrackOffsets[k].Rot;
                        Vector4 erotQ = seqn.CompressedTrackOffsets[k].Rot;
                        Quaternion q1 = Vec4ToQ(srotQ);
                        Quaternion q2 = Vec4ToQ(erotQ);
                        float t = j / (float)(inf.NumRawFrames - 1);
                        Vector3 currV = Vector3.Lerp(fromV, toV, t);
                        Quaternion qc = Quaternion.Slerp(q1, q2, t);
                        PSAFile.PSAAnimKeys key = new PSAFile.PSAAnimKeys
                        {
                            location = new PSAFile.PSAPoint(currV),
                            rotation = new PSAFile.PSAQuad(QToVec4(qc)),
                            time = 1
                        };
                        d.Keys.Add(key);
                    }
                currframe += seq.NumFrames;
            }
            AnimSequence s1 = new AnimSequence(pcc.getUExport(Sequences[Sequences.Count-1]));
            AnimSequence s2;
            if (s1.bNoLoopingInterpolation)
                s2 = new AnimSequence(pcc.getUExport(Sequences[Sequences.Count - 1]));
            else
                s2 = new AnimSequence(pcc.getUExport(Sequences[0]));
            PSAFile.PSAAnimInfo inf2 = new PSAFile.PSAAnimInfo();
            inf2.AnimRate = 30;
            inf2.TotalBones = d.Bones.Count;
            inf2.FirstRawFrame = currframe;
            inf2.TrackTime = inf2.NumRawFrames = s1.NumFrames;
            inf2.KeyQuotum = inf2.NumRawFrames * inf2.TotalBones;
            inf2.name = s1.SequenceName;
            inf2.group = "None";
            d.Infos.Add(inf2);
            for (int j = 0; j < inf2.NumRawFrames; j++)
                for (int k = 0; k < inf2.TotalBones; k++)
                {
                    Vector3 fromV = s1.CompressedTrackOffsets[k].Trans;
                    Vector3 toV = s2.CompressedTrackOffsets[k].Trans;
                    Vector4 srotQ = s1.CompressedTrackOffsets[k].Rot;
                    Vector4 erotQ = s2.CompressedTrackOffsets[k].Rot;
                    Quaternion q1 = Vec4ToQ(srotQ);
                    Quaternion q2 = Vec4ToQ(erotQ);
                    float t = j / (float)(inf2.NumRawFrames - 1);
                    Vector3 currV = Vector3.Lerp(fromV, toV, t);
                    Quaternion qc = Quaternion.Slerp(q1, q2, t);
                    PSAFile.PSAAnimKeys key = new PSAFile.PSAAnimKeys
                    {
                        location = new PSAFile.PSAPoint(currV),
                        rotation = new PSAFile.PSAQuad(QToVec4(qc)),
                        time = 1
                    };
                    d.Keys.Add(key);
                }
            psa.data = d;
            psa.ExportPSA(path);
        }

        public bool ImportFromPSA(string path)
        {
            PSAFile psa = new PSAFile();
            psa.ImportPSA(path);
            PSAFile.PSAData d = psa.data;
            DebugOutput.PrintLn("Checking data...");
            if (d.Bones.Count != SetData.TrackBoneNames.Count)
            {
                MessageBox.Show("Cant import: different count of bones");
                return false;
            }
            for (int i = 0; i < SetData.TrackBoneNames.Count; i++)
                if (d.Bones[i].name != SetData.TrackBoneNames[i])
                {
                    MessageBox.Show("Cant import: couldnt match all bones");
                    return false;
                }
            if (d.Infos.Count != Sequences.Count)
            {
                MessageBox.Show("Cant import: different count of sequences");
                return false;
            }
            for (int i = 0; i < Sequences.Count; i++)
            {
                AnimSequence ans = new AnimSequence(pcc.getUExport(Sequences[i]));
                if (d.Infos[i].name != ans.SequenceName)
                {
                    MessageBox.Show("Cant import: couldnt match all sequences");
                    return false;
                }
            }
            int pos = 0;
            List<Vector4> rot = new List<Vector4>();
            for (int i = 0; i < Sequences.Count; i++)
            {
                DebugOutput.PrintLn($"Importing into AnimSequence #{Sequences[i]} ...");
                AnimSequence ans = new AnimSequence(pcc.getUExport(Sequences[i]));
                PSAFile.PSAAnimInfo inf = d.Infos[i];
                var loc = new List<Vector3>();
                for (int j = 0; j < inf.TotalBones; j++)
                {
                    PSAFile.PSAAnimKeys key = d.Keys[pos + j];
                    loc.Add(key.location.ToVector3());
                    rot.Add(key.rotation.ToVector4());
                }
                ans.ImportKeys(loc.ToArray(), rot.ToArray(), inf.NumRawFrames);
                ans.SaveChanges();
                pos += inf.KeyQuotum;
            }
            pcc.save();
            return true;
        }

        public Quaternion Vec4ToQ(Vector4 v)
        {
            return new Quaternion(v.X, v.Y, v.Z, v.W);
        }

        public Vector4 QToVec4(Quaternion q)
        {
            return new Vector4(q.X, q.Y, q.Z, q.W);
        }
    }
}